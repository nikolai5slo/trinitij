<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>Trinitij</title>
	<style>
	html, body {
		overflow: hidden;
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
	}

	#canvas {
		width: 100%;
		height: 100%;
		touch-action: none;
	}
	</style>
	<script src="http://www.babylonjs.com/hand.minified-1.2.js"></script>
    <script src="http://www.babylonjs.com/cannon.js"></script>
    <script src="http://www.babylonjs.com/oimo.js"></script>
    <script src="http://www.babylonjs.com/babylon.js"></script>
	<script src="js/oimo.min.js"></script>
	<script src="js/main.js"></script>


	<script type="application/vertexShader" id="vertexShaderCode">
        precision highp float;
 
        // Attributes
        attribute vec3 position;
        attribute vec2 uv;
 
        // Uniforms
        uniform mat4 worldViewProjection;
 
        // Normal
        varying vec2 vUV;
        varying vec2 resolution;
        varying float time;
 
        void main(void) {
        	gl_Position = worldViewProjection * vec4(position, 1.0);
 
        	vUV = uv;
        	resolution = vec2(1.0,1.0);
        	time = 1.0;
        }
    </script>
   
    <script type="application/fragmentShader" id="fragmentShaderCode">
    precision highp float;


    varying vec2 vUV;
    varying vec2 resolution;
    varying float time;

	/**
	 * Starscroll by LJ
	 * @Gtr why so complicated :) ? 
	 *Thank you mr LJ ,*/

	float rand (in vec2 uv) { return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241); }
	const vec2 O = vec2(0.,1.);
	float noise (in vec2 uv) {
		vec2 b = floor(uv);
		return mix(mix(rand(b),rand(b+O.yx),.5),mix(rand(b+O),rand(b+O.yy),.5),.5);
	}

	#define DIR_RIGHT -1.
	#define DIR_LEFT 1.
	#define DIRECTION DIR_LEFT

	#define LAYERS 5
	#define SPEED 20.
	#define SIZE 5.

	void main( void ) {

		vec2 uv = ( vUV.xy / resolution.xy )*SIZE;
		
		float stars = 0.;
		float fl, s;
		for (int layer = 0; layer < LAYERS; layer++) {
			fl = float(layer);
			s = (200.-fl*30.);
			stars += step(.1,pow(noise(mod(vec2(uv.x*s + time*SPEED*DIRECTION - fl*100.,uv.y*s),resolution.x)),18.)) * (fl/float(LAYERS));
		}
		gl_FragColor = vec4( vec3(stars), 1.0 );

	}
	/*
        precision highp float;
        varying vec2 vUV;
 
        uniform sampler2D textureSampler;
 
        void main(void) {
        gl_FragColor = texture2D(textureSampler, vUV);
        }
        */
    </script>
 
</head>

<body>
	<canvas id="canvas"></canvas>
</body>

</html>